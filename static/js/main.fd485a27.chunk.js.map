{"version":3,"sources":["../../src/components/utils.ts","../../src/components/ScrollSpyProvider.tsx","../../src/components/ScrollSpyComponent.tsx","../../src/components/ScrollSpyTopic.tsx","components/Navbar.js","App.js","index.js"],"names":["getTitleFromAttributes","instance","getTopicFromAttributes","attr","attribute","ScrollSpyContext","React","ScrollSpyProvider","children","options","threshold","nodes","setNodes","currentObserver","window","entries","entry","n","isActive","current","state","sortedNodeTree","item","parentObj","obj","arr","actions","addNode","title","id","topic","parent","value","ScrollSpyComponent","inheritedTopic","parentTopic","rest","ref","context","Error","useScrollSpy","undefined","ScrollSpyTopic","childrenWithTopic","renderArr","map","node","key","style","display","fontWeight","color","href","Navbar","useScrollSpyState","className","Object","keys","Array","isArray","nestedTopic","some","ExampleContent","background","height","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.fd485a27.chunk.js","sourcesContent":["export const getTitleFromAttributes = (\n  instance: HTMLDivElement | Element,\n): string => {\n  return instance.attributes.getNamedItem('data-title')!.value || 'Undefined'\n}\n\nexport const getTopicFromAttributes = (\n  instance: HTMLDivElement | Element,\n  attr = 'data-topic',\n): undefined | string => {\n  const attribute = instance.attributes.getNamedItem(attr)\n  if (attribute) {\n    return attribute.value\n  } else {\n    return undefined\n  }\n}\n","import React from 'react'\nimport { getTitleFromAttributes, getTopicFromAttributes } from './utils'\n\ninterface ScrollItem {\n  title: string\n  id: string\n  isActive: boolean\n  topic?: string\n  parent?: string\n}\n\ninterface Tree {\n  unsorted: ScrollItem[]\n  [key: string]: any\n}\n\ninterface ScrollSpyState {\n  addNode: (instance: HTMLDivElement | null) => void\n  nodes: ScrollItem[]\n  sortedNodeTree: Tree\n}\n\ninterface ScrollSpyProviderProps {\n  children?: React.ReactNode\n\n  // The threshold is a number from 0-1 indicating how much the child should be\n  // in view before becoming the current node\n  threshold?: number\n  options?: IntersectionObserverInit\n}\n\nconst ScrollSpyContext = React.createContext<ScrollSpyState | undefined>(\n  undefined,\n)\n\nexport default function ScrollSpyProvider({\n  children,\n  options = { threshold: 0.5 },\n}: ScrollSpyProviderProps) {\n  const [nodes, setNodes] = React.useState<ScrollItem[]>([])\n\n  // We want the IntersectionObserver inside a useRef because it will\n  // not trigger a rerender unlike useState\n  const { current: currentObserver } = React.useRef(\n    new window.IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // If the entry past the threshold, set it as the current node\n        if (entry.intersectionRatio > (options.threshold || 0.5)) {\n          // This may not work on older browsers, but pushState doesnt\n          // trigger a hashchange which would cause a jumping\n          window.history.pushState(null, '', `#${entry.target.id}`)\n          setNodes((nodes) =>\n            nodes.map((n) =>\n              n.id === entry.target.id\n                ? { ...n, isActive: true }\n                : { ...n, isActive: false },\n            ),\n          )\n        }\n      })\n    }, options),\n  )\n\n  // We need to seperate the state from the actions because we dont want\n  // addNode to update everytime currentNode or nodes updates\n  const state = React.useMemo(\n    () => ({\n      nodes,\n      // This tree implementation is a little complex, but it consolidate repeated\n      // topics and supports up to 2 levels of depth\n      sortedNodeTree: nodes.reduce((obj: any, item) => {\n        if (item.parent) {\n          const parentObj = obj[item.parent] || {}\n          const arr = parentObj[item.topic || 'unsorted'] || []\n          return {\n            ...obj,\n            [item.parent]: {\n              ...parentObj,\n              [item.topic || 'unsorted']: [...arr, item],\n            },\n          }\n        } else {\n          const arr = obj[item.topic || 'unsorted'] || []\n          return {\n            ...obj,\n            [item.topic || 'unsorted']: [...arr, item],\n          }\n        }\n      }, {}),\n    }),\n    [nodes],\n  )\n\n  // We memorize the state & actions to prevent occasional unnecessary rerenders\n  const actions = React.useMemo(\n    () => ({\n      // Because we can pass in a function as a 'ref' we can use this function\n      // to add the node to the observer 'tree'\n      addNode: (instance: HTMLDivElement | null): void => {\n        if (instance) {\n          currentObserver.observe(instance)\n\n          setNodes((prevNodes) => [\n            ...prevNodes,\n            {\n              title: getTitleFromAttributes(instance),\n              id: instance.id,\n              isActive: false,\n              topic: getTopicFromAttributes(instance),\n              parent: getTopicFromAttributes(instance, 'data-parent-topic'),\n            },\n          ])\n        }\n      },\n    }),\n    [currentObserver],\n  )\n\n  // Cleanup\n  React.useEffect(() => {\n    return () => currentObserver.disconnect()\n  }, [currentObserver])\n\n  return (\n    <ScrollSpyContext.Provider value={{ ...state, ...actions }}>\n      {children}\n    </ScrollSpyContext.Provider>\n  )\n}\n\nexport const useScrollSpy = () => {\n  const context = React.useContext(ScrollSpyContext)\n  if (!context) {\n    throw new Error('useScrollSpy must be used within the ScrollSpyProvider')\n  }\n\n  return context.addNode\n}\n\nexport const useScrollSpyState = () => {\n  const context = React.useContext(ScrollSpyContext)\n  if (!context) {\n    throw new Error(\n      'useScrollSpyState must be used within the ScrollSpyProvider',\n    )\n  }\n\n  return context\n}\n","import React from 'react'\nimport { useScrollSpy } from './ScrollSpyProvider'\n\ninterface ScrollSpyComponentProps\n  extends React.DetailedHTMLProps<\n    React.HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  > {\n  children?: React.ReactNode\n  title: string\n  id: string\n  inheritedTopic?: string\n  parentTopic?: string\n}\n\nexport default function ScrollSpyComponent({\n  children,\n  title,\n  id,\n  inheritedTopic,\n  parentTopic,\n  ...rest\n}: ScrollSpyComponentProps) {\n  const ref = useScrollSpy()\n\n  // Because the IntersectionObserver passes back a DOM node, not a\n  // react one, we need to forward the data-title to pick back up in state\n  return (\n    <div\n      id={id}\n      ref={ref}\n      data-title={title}\n      data-topic={parentTopic ? inheritedTopic : undefined}\n      data-parent-topic={!parentTopic ? inheritedTopic : parentTopic}\n      {...rest}\n    >\n      {children}\n    </div>\n  )\n}\n","import React from 'react'\n\ninterface ScrollSpyComponentProps\n  extends React.DetailedHTMLProps<\n    React.HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  > {\n  children?: React.ReactNode\n  title: string\n  id: string\n  inheritedTopic?: string\n  parentTopic?: string\n}\n\ninterface ScrollSpyTopicProps {\n  children?: React.ReactNode\n  topic: string\n  inheritedTopic?: string\n}\n\nexport default function ScrollSpyTopic({\n  children,\n  topic,\n  inheritedTopic\n}: ScrollSpyTopicProps) {\n  const childrenWithTopic = React.Children.map(children, (child) => {\n    if (!React.isValidElement<ScrollSpyComponentProps>(child)) {\n      return child\n    }\n    return React.cloneElement(child, {\n      inheritedTopic: topic,\n      parentTopic: inheritedTopic\n    })\n  })\n\n  return <div>{childrenWithTopic}</div>\n}\n","import React from 'react'\nimport { useScrollSpyState } from 'scroll-spy'\n\nfunction renderArr(arr) {\n  return arr.map((node) => {\n    return (\n      <li key={node.id}>\n        <a\n          style={{\n            display: 'block',\n            fontWeight: node.isActive ? 'bold' : 'normal',\n            color: node.isActive ? 'var(--color-fuchsia)' : '#5850ec'\n          }}\n          href={`#${node.id}`}\n        >\n          {node.title}\n        </a>\n      </li>\n    )\n  })\n}\n\n// This is a simple implementation of ScrollSpy\nexport default function Navbar() {\n  const { sortedNodeTree } = useScrollSpyState()\n\n  return (\n    <div className='navbar-container'>\n      <ul>\n        {Object.keys(sortedNodeTree).map((topic) => {\n          // This is all of the unsorted arrays, first layer of arrays\n          if (Array.isArray(sortedNodeTree[topic])) {\n            return renderArr(sortedNodeTree[topic])\n          } else {\n            // We then rendering the parent and topic\n            return (\n              <div key={topic}>\n                <h2>{topic}</h2>\n                {Object.keys(sortedNodeTree[topic]).map((nestedTopic) => {\n                  return (\n                    <ul key={nestedTopic}>\n                      {nestedTopic !== 'unsorted' && (\n                        <h3\n                          style={{\n                            fontWeight: sortedNodeTree[topic][nestedTopic].some(\n                              (n) => n.isActive\n                            )\n                              ? 'bold'\n                              : 'normal'\n                          }}\n                        >\n                          {nestedTopic}\n                        </h3>\n                      )}\n                      {renderArr(sortedNodeTree[topic][nestedTopic])}\n                    </ul>\n                  )\n                })}\n              </div>\n            )\n          }\n        })}\n      </ul>\n    </div>\n  )\n}\n","import React from 'react'\nimport {\n  ScrollSpyProvider,\n  ScrollSpyComponent,\n  ScrollSpyTopic\n} from 'scroll-spy'\nimport Navbar from './components/Navbar'\nimport './App.css'\n\nconst ExampleContent = ({ children, color }) => (\n  <div style={{ background: `var(--color-${color})`, height: '100vh' }}>\n    <h1>{children}</h1>\n  </div>\n)\n\nfunction App() {\n  return (\n    <ScrollSpyProvider>\n      <Navbar />\n      <ScrollSpyTopic topic='Introduction'>\n        <ScrollSpyTopic topic='Prepare'>\n          <ScrollSpyComponent\n            id='get-your-supplies'\n            title='Get your supplies ready'\n          >\n            <ExampleContent color='navy'>\n              Get your supplies ready\n            </ExampleContent>\n          </ScrollSpyComponent>\n          <ScrollSpyComponent id='watch-mars-base' title='Watch: Mars Base'>\n            <ExampleContent color='blue'>Watch this video</ExampleContent>\n          </ScrollSpyComponent>\n          <ScrollSpyComponent id='read-space-suits' title='Read space suits'>\n            <ExampleContent color='aqua'>Read space suits</ExampleContent>\n          </ScrollSpyComponent>\n        </ScrollSpyTopic>\n        <ScrollSpyTopic topic='Design your repair kit'>\n          <ScrollSpyComponent\n            id='gather-materials'\n            title='Gather your materials'\n          >\n            <ExampleContent color='teal'>Gather your materials</ExampleContent>\n          </ScrollSpyComponent>\n        </ScrollSpyTopic>\n      </ScrollSpyTopic>\n    </ScrollSpyProvider>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}